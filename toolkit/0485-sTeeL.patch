From 8c62c84f2b85bebf0a3f5fe588aa19e9d113996a Mon Sep 17 00:00:00 2001
From: sTeeL Mental <steel.mental@gmail.com>
Date: Fri, 21 Jun 2013 14:44:08 -0400
Subject: [PATCH] Fix cd efi boot bug, add chainload2

Signed-off-by: Peter Jones <grub2-owner@fedoraproject.org>
---
diff --git a/grub-core/Makefile.core.am b/grub-core/Makefile.core.am
index 79d22c3..eb2066e 100644
--- a/grub-core/Makefile.core.am
+++ b/grub-core/Makefile.core.am
@@ -37523,6 +37523,29 @@ chain.marker: $(chain_module_SOURCES) $(nodist_chain_module_SOURCES)
 	grep 'MARKER' $@.new > $@; rm -f $@.new
 endif
 
+if COND_i386_efi
+platform_PROGRAMS += chain2.module
+MODULE_FILES += chain2.module$(EXEEXT)
+chain2_module_SOURCES  = loader/efi/chainloader2.c  ## platform sources
+nodist_chain2_module_SOURCES  =  ## platform nodist sources
+chain2_module_LDADD  = 
+chain2_module_CFLAGS  = $(AM_CFLAGS) $(CFLAGS_MODULE) 
+chain2_module_LDFLAGS  = $(AM_LDFLAGS) $(LDFLAGS_MODULE) 
+chain2_module_CPPFLAGS  = $(AM_CPPFLAGS) $(CPPFLAGS_MODULE) 
+chain2_module_CCASFLAGS  = $(AM_CCASFLAGS) $(CCASFLAGS_MODULE) 
+EXTRA_DIST += 
+BUILT_SOURCES += $(nodist_chain2_module_SOURCES)
+CLEANFILES += $(nodist_chain2_module_SOURCES)
+MOD_FILES += chain2.mod
+MARKER_FILES += chain2.marker
+CLEANFILES += chain2.marker
+
+chain2.marker: $(chain2_module_SOURCES) $(nodist_chain2_module_SOURCES)
+	$(TARGET_CPP) -DGRUB_LST_GENERATOR $(CPPFLAGS_MARKER) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(chain2_module_CPPFLAGS) $(CPPFLAGS) $^ > $@.new || (rm -f $@; exit 1)
+	grep 'MARKER' $@.new > $@; rm -f $@.new
+
+endif
+
 if COND_i386_coreboot
 platform_PROGRAMS += chain.module
 MODULE_FILES += chain.module$(EXEEXT)
@@ -37567,6 +37590,28 @@ chain.marker: $(chain_module_SOURCES) $(nodist_chain_module_SOURCES)
 	grep 'MARKER' $@.new > $@; rm -f $@.new
 endif
 
+if COND_x86_64_efi
+platform_PROGRAMS += chain2.module
+MODULE_FILES += chain2.module$(EXEEXT)
+chain2_module_SOURCES  = loader/efi/chainloader2.c  ## platform sources
+nodist_chain2_module_SOURCES  =  ## platform nodist sources
+chain2_module_LDADD  = 
+chain2_module_CFLAGS  = $(AM_CFLAGS) $(CFLAGS_MODULE) 
+chain2_module_LDFLAGS  = $(AM_LDFLAGS) $(LDFLAGS_MODULE) 
+chain2_module_CPPFLAGS  = $(AM_CPPFLAGS) $(CPPFLAGS_MODULE) 
+chain2_module_CCASFLAGS  = $(AM_CCASFLAGS) $(CCASFLAGS_MODULE) 
+EXTRA_DIST += 
+BUILT_SOURCES += $(nodist_chain2_module_SOURCES)
+CLEANFILES += $(nodist_chain2_module_SOURCES)
+MOD_FILES += chain2.mod
+MARKER_FILES += chain2.marker
+CLEANFILES += chain2.marker
+
+chain2.marker: $(chain2_module_SOURCES) $(nodist_chain2_module_SOURCES)
+	$(TARGET_CPP) -DGRUB_LST_GENERATOR $(CPPFLAGS_MARKER) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(chain2_module_CPPFLAGS) $(CPPFLAGS) $^ > $@.new || (rm -f $@; exit 1)
+	grep 'MARKER' $@.new > $@; rm -f $@.new
+endif
+
 if COND_ia64_efi
 platform_PROGRAMS += chain.module
 MODULE_FILES += chain.module$(EXEEXT)
@@ -37589,6 +37634,28 @@ chain.marker: $(chain_module_SOURCES) $(nodist_chain_module_SOURCES)
 	grep 'MARKER' $@.new > $@; rm -f $@.new
 endif
 
+if COND_ia64_efi
+platform_PROGRAMS += chain2.module
+MODULE_FILES += chain2.module$(EXEEXT)
+chain2_module_SOURCES  = loader/efi/chainloader2.c  ## platform sources
+nodist_chain2_module_SOURCES  =  ## platform nodist sources
+chain2_module_LDADD  = 
+chain2_module_CFLAGS  = $(AM_CFLAGS) $(CFLAGS_MODULE) 
+chain2_module_LDFLAGS  = $(AM_LDFLAGS) $(LDFLAGS_MODULE) 
+chain2_module_CPPFLAGS  = $(AM_CPPFLAGS) $(CPPFLAGS_MODULE) 
+chain2_module_CCASFLAGS  = $(AM_CCASFLAGS) $(CCASFLAGS_MODULE) 
+EXTRA_DIST += 
+BUILT_SOURCES += $(nodist_chain2_module_SOURCES)
+CLEANFILES += $(nodist_chain2_module_SOURCES)
+MOD_FILES += chain2.mod
+MARKER_FILES += chain2.marker
+CLEANFILES += chain2.marker
+
+chain2.marker: $(chain2_module_SOURCES) $(nodist_chain2_module_SOURCES)
+	$(TARGET_CPP) -DGRUB_LST_GENERATOR $(CPPFLAGS_MARKER) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(chain2_module_CPPFLAGS) $(CPPFLAGS) $^ > $@.new || (rm -f $@; exit 1)
+	grep 'MARKER' $@.new > $@; rm -f $@.new
+endif
+
 if COND_i386_pc
 platform_PROGRAMS += mmap.module
 MODULE_FILES += mmap.module$(EXEEXT)
diff --git a/grub-core/Makefile.core.def b/grub-core/Makefile.core.def
index 08089de..fb0362d 100644
--- a/grub-core/Makefile.core.def
+++ b/grub-core/Makefile.core.def
@@ -1560,6 +1560,12 @@ module = {
 };
 
 module = {
+  name = chain2;
+  efi = loader/efi/chainloader2.c;
+  enable = efi;
+};
+
+module = {
   name = mmap;
   common = mmap/mmap.c;
   x86 = mmap/i386/uppermem.c;
diff --git a/grub-core/disk/efi/efidisk.c b/grub-core/disk/efi/efidisk.c
index 08c303e..1898c52 100644
--- a/grub-core/disk/efi/efidisk.c
+++ b/grub-core/disk/efi/efidisk.c
@@ -198,6 +198,8 @@ is_child (struct grub_efidisk_data *child,
 
 #define FOR_CHILDREN(p, dev) for (p = dev; p; p = p->next) if (is_child (p, d))
 
+#define DEBUG_NAMES 1
+
 /* Add a device into a list of devices in an ascending order.  */
 static void
 add_device (struct grub_efidisk_data **devices, struct grub_efidisk_data *d)
@@ -799,16 +801,6 @@ grub_efidisk_get_device_name (grub_efi_handle_t *handle)
   if (! ldp)
     return 0;
 
-  if (GRUB_EFI_DEVICE_PATH_TYPE (ldp) == GRUB_EFI_MEDIA_DEVICE_PATH_TYPE &&
-      (GRUB_EFI_DEVICE_PATH_SUBTYPE (ldp) == GRUB_EFI_CDROM_DEVICE_PATH_SUBTYPE))
-    {
-      ldp->type = GRUB_EFI_END_DEVICE_PATH_TYPE;
-      ldp->subtype = GRUB_EFI_END_ENTIRE_DEVICE_PATH_SUBTYPE;
-      ldp->length[0] = 4;
-      ldp->length[1] = 0;
-      ldp = find_last_device_path(dp);
-    }
-
   if (GRUB_EFI_DEVICE_PATH_TYPE (ldp) == GRUB_EFI_MEDIA_DEVICE_PATH_TYPE
       && (GRUB_EFI_DEVICE_PATH_SUBTYPE (ldp)
 	  == GRUB_EFI_HARD_DRIVE_DEVICE_PATH_SUBTYPE))
@@ -870,7 +862,31 @@ grub_efidisk_get_device_name (grub_efi_handle_t *handle)
 
       return dev_name;
     }
-  else
+  else if (GRUB_EFI_DEVICE_PATH_TYPE (ldp) == GRUB_EFI_MEDIA_DEVICE_PATH_TYPE &&
+      (GRUB_EFI_DEVICE_PATH_SUBTYPE (ldp) == GRUB_EFI_CDROM_DEVICE_PATH_SUBTYPE))
+    {
+	  grub_efi_device_path_t *dup_dp, *dup_ldp;
+	  dup_dp = duplicate_device_path (dp);
+
+	  if (! dup_dp)
+		return 0;
+
+	  dup_ldp = find_last_device_path (dup_dp);
+	  dup_ldp->type = GRUB_EFI_END_DEVICE_PATH_TYPE;
+	  dup_ldp->subtype = GRUB_EFI_END_ENTIRE_DEVICE_PATH_SUBTYPE;
+	  dup_ldp->length[0] = 4;
+	  dup_ldp->length[1] = 0;
+
+	  if (!get_diskname_from_path (dup_dp, device_name))
+	  {
+		grub_free (dup_dp);
+		return 0;
+	  }
+
+	  grub_free (dup_dp);
+	  return grub_strdup (device_name);
+    }
+  else 
     {
       /* This should be an entire disk.  */
       if (!get_diskname_from_path (dp, device_name))
diff --git a/grub-core/loader/efi/chainloader2.c b/grub-core/loader/efi/chainloader2.c
new file mode 100644
index 0000000..5eed6f7
--- /dev/null
+++ b/grub-core/loader/efi/chainloader2.c
@@ -0,0 +1,298 @@
+/* chainloader2.c - boot another boot loader, fake from fw */
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (C) 2002,2004,2006,2007,2008  Free Software Foundation, Inc.
+ *
+ *  GRUB is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/* TODO: support load options.  */
+
+#include <grub/loader.h>
+#include <grub/file.h>
+#include <grub/err.h>
+#include <grub/device.h>
+#include <grub/disk.h>
+#include <grub/misc.h>
+#include <grub/charset.h>
+#include <grub/mm.h>
+#include <grub/types.h>
+#include <grub/dl.h>
+#include <grub/efi/api.h>
+#include <grub/efi/efi.h>
+#include <grub/efi/disk.h>
+#include <grub/command.h>
+#include <grub/i18n.h>
+#include <grub/net.h>
+#if defined (__i386__) || defined (__x86_64__)
+#include <grub/macho.h>
+#include <grub/i386/macho.h>
+#endif
+
+GRUB_MOD_LICENSE ("GPLv3+");
+
+static grub_dl_t my_mod;
+
+static grub_efi_physical_address_t address;
+static grub_efi_uintn_t pages;
+static grub_efi_handle_t image_handle;
+static grub_efi_char16_t *cmdline;
+
+static grub_err_t
+grub_chainloader_unload2 (void)
+{
+  grub_efi_boot_services_t *b;
+
+  b = grub_efi_system_table->boot_services;
+  efi_call_1 (b->unload_image, image_handle);
+  efi_call_2 (b->free_pages, address, pages);
+
+  grub_free (cmdline);
+  cmdline = 0;
+
+  grub_dl_unref (my_mod);
+  return GRUB_ERR_NONE;
+}
+
+static grub_err_t
+grub_chainloader_boot2 (void)
+{
+  grub_efi_boot_services_t *b;
+  grub_efi_status_t status;
+  grub_efi_uintn_t exit_data_size;
+  grub_efi_char16_t *exit_data = NULL;
+
+  b = grub_efi_system_table->boot_services;
+  status = efi_call_3 (b->start_image, image_handle, &exit_data_size, &exit_data);
+  if (status != GRUB_EFI_SUCCESS)
+    {
+      if (exit_data)
+	{
+	  char *buf;
+
+	  buf = grub_malloc (exit_data_size * 4 + 1);
+	  if (buf)
+	    {
+	      *grub_utf16_to_utf8 ((grub_uint8_t *) buf,
+				   exit_data, exit_data_size) = 0;
+
+	      grub_error (GRUB_ERR_BAD_OS, buf);
+	      grub_free (buf);
+	    }
+	}
+      else
+	grub_error (GRUB_ERR_BAD_OS, "unknown error");
+    }
+
+  if (exit_data)
+    efi_call_1 (b->free_pool, exit_data);
+
+  grub_loader_unset ();
+
+  return grub_errno;
+}
+
+
+static grub_err_t
+grub_cmd_chainloader2 (grub_command_t cmd __attribute__ ((unused)),
+		      int argc, char *argv[])
+{
+  grub_file_t file = 0;
+  grub_ssize_t size;
+  grub_efi_status_t status;
+  grub_efi_boot_services_t *b;
+  grub_efi_loaded_image_t *loaded_image, * loader_image;
+  char *filename;
+  void *boot_image = 0;
+
+  if (argc == 0)
+    return grub_error (GRUB_ERR_BAD_ARGUMENT, N_("filename expected"));
+  filename = argv[0];
+
+  grub_dl_ref (my_mod);
+
+  /* Initialize some global variables.  */
+  address = 0;
+  image_handle = 0;
+
+  b = grub_efi_system_table->boot_services;
+
+  file = grub_file_open (filename);
+  if (! file)
+    goto fail;
+
+  /* Get the root device's device path.  */
+  loader_image = grub_efi_get_loaded_image (grub_efi_image_handle);
+  if(loader_image == NULL ) {
+      grub_error (GRUB_ERR_BAD_OS, N_("can not get loader image"));
+      goto fail;
+  }
+  if(loader_image->parent_handle == NULL ) {
+      grub_error (GRUB_ERR_BAD_OS, N_("can not get loader image's device handle"));
+      goto fail;
+  }
+
+  grub_printf ("faked file path: ");
+  grub_efi_print_device_path (loader_image->file_path);
+
+  size = grub_file_size (file);
+  if (!size)
+    {
+      grub_error (GRUB_ERR_BAD_OS, N_("premature end of file %s"),
+		  filename);
+      goto fail;
+    }
+  pages = (((grub_efi_uintn_t) size + ((1 << 12) - 1)) >> 12);
+
+  status = efi_call_4 (b->allocate_pages, GRUB_EFI_ALLOCATE_ANY_PAGES,
+			      GRUB_EFI_LOADER_CODE,
+			      pages, &address);
+  if (status != GRUB_EFI_SUCCESS)
+    {
+      grub_dprintf ("chain", "Failed to allocate %u pages\n",
+		    (unsigned int) pages);
+      grub_error (GRUB_ERR_OUT_OF_MEMORY, N_("out of memory"));
+      goto fail;
+    }
+
+  boot_image = (void *) ((grub_addr_t) address);
+  if (grub_file_read (file, boot_image, size) != size)
+    {
+      if (grub_errno == GRUB_ERR_NONE)
+	grub_error (GRUB_ERR_BAD_OS, N_("premature end of file %s"),
+		    filename);
+
+      goto fail;
+    }
+
+#if defined (__i386__) || defined (__x86_64__)
+  if (size >= (grub_ssize_t) sizeof (struct grub_macho_fat_header))
+    {
+      struct grub_macho_fat_header *head = boot_image;
+      if (head->magic
+	  == grub_cpu_to_le32_compile_time (GRUB_MACHO_FAT_EFI_MAGIC))
+	{
+	  grub_uint32_t i;
+	  struct grub_macho_fat_arch *archs
+	    = (struct grub_macho_fat_arch *) (head + 1);
+	  for (i = 0; i < grub_cpu_to_le32 (head->nfat_arch); i++)
+	    {
+	      if (GRUB_MACHO_CPUTYPE_IS_HOST_CURRENT (archs[i].cputype))
+		break;
+	    }
+	  if (i == grub_cpu_to_le32 (head->nfat_arch))
+	    {
+	      grub_error (GRUB_ERR_BAD_OS, "no compatible arch found");
+	      goto fail;
+	    }
+	  if (grub_cpu_to_le32 (archs[i].offset)
+	      > ~grub_cpu_to_le32 (archs[i].size)
+	      || grub_cpu_to_le32 (archs[i].offset)
+	      + grub_cpu_to_le32 (archs[i].size)
+	      > (grub_size_t) size)
+	    {
+	      grub_error (GRUB_ERR_BAD_OS, N_("premature end of file %s"),
+			  filename);
+	      goto fail;
+	    }
+	  boot_image = (char *) boot_image + grub_cpu_to_le32 (archs[i].offset);
+	  size = grub_cpu_to_le32 (archs[i].size);
+	}
+    }
+#endif
+
+  status = efi_call_6 (b->load_image, 0, loader_image->parent_handle, loader_image->file_path,
+		       boot_image, size,
+		       &image_handle);
+  if (status != GRUB_EFI_SUCCESS)
+    {
+      if (status == GRUB_EFI_OUT_OF_RESOURCES)
+	grub_error (GRUB_ERR_OUT_OF_MEMORY, "out of resources");
+      else
+	grub_error (GRUB_ERR_BAD_OS, "cannot load image");
+
+      goto fail;
+    }
+
+  /* LoadImage does not set a device handler when the image is
+     loaded from memory, so it is necessary to set it explicitly here.
+     This is a mess.  */
+  loaded_image = grub_efi_get_loaded_image (image_handle);
+  if (! loaded_image)
+    {
+      grub_error (GRUB_ERR_BAD_OS, "no loaded image available");
+      goto fail;
+    }
+  loaded_image->device_handle = loader_image->device_handle;
+
+  grub_file_close (file);
+
+  if (argc > 1)
+    {
+      int i, len;
+      grub_efi_char16_t *p16;
+
+      for (i = 1, len = 0; i < argc; i++)
+        len += grub_strlen (argv[i]) + 1;
+
+      len *= sizeof (grub_efi_char16_t);
+      cmdline = p16 = grub_malloc (len);
+      if (! cmdline)
+        goto fail;
+
+      for (i = 1; i < argc; i++)
+        {
+          char *p8;
+
+          p8 = argv[i];
+          while (*p8)
+            *(p16++) = *(p8++);
+
+          *(p16++) = ' ';
+        }
+      *(--p16) = 0;
+
+      loaded_image->load_options = cmdline;
+      loaded_image->load_options_size = len;
+    }
+
+  grub_loader_set (grub_chainloader_boot2, grub_chainloader_unload2, 0);
+  return 0;
+
+ fail:
+
+  if (file)
+    grub_file_close (file);
+
+  if (address)
+    efi_call_2 (b->free_pages, address, pages);
+
+  grub_dl_unref (my_mod);
+
+  return grub_errno;
+}
+
+static grub_command_t cmd;
+
+GRUB_MOD_INIT(chainloader2)
+{
+  cmd = grub_register_command ("chainloader2", grub_cmd_chainloader2,
+			       0, N_("Load another boot loader, fake from fw."));
+  my_mod = mod;
+}
+
+GRUB_MOD_FINI(chainloader2)
+{
+  grub_unregister_command (cmd);
+}
